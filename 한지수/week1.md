# 1. 오브젝트와 의존관계

1. 초난감 DAO

DAO(Data Access Object) 는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트이다.

- 사용자 정보를 JDBC API를 통해 DB에 저장하고 조회할 수 있는 간단한 DAO 만들기. → User.java 클래스 생성하고 이 정보가 보관될 DB 의 테이블 생성 → 사용자 정보의 등록과 조회가 되는 초간단 DAO 와 테스트용 메소드 완성 → 이 DAO는 문제가 많은 코드이므로 객체지향 기술의 원리에 충실한 스프링 스타일의 코드로 개선
1. DAO의 분리
- 관심사의 분리 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 하려면 ‘분리와 확장’을 고려한 설계가 필요하다 ‘관심사의 분리’는 프로그램의 기초개념이며, 뭉쳐 있는 여러 종류의 관심사를 적절하게 구분하고 따로 분리하는 작업을 해줘야만 할 때가 온다.
- 커넥션 만들기의 추출 UserDao 는 현재 초난감 상태이므로, 필요하지만 생략된 것이 많다. 위에 생성한 DAO 코드에는 예외상황에 대한 처리가 전혀 없다. 가장 문제가 되는것은 DB 연결을 위한 Connection 오브젝트를 가져오는 부분이다. 현재 DB커넥션을 가져오는 코드는 다른 관심사와 섞여있다. 더 큰 문제는 동일한 코드가 다른 메서드에 중복되어 있다는 점이다. 앞으로 수백, 수천개의 DAO 메소드를 만들게 될지 모르는데 그렇게 된다면 DB 커넥션을 가져오는 코드가 여기저기 중복되서 나타날 것이다.

/ 중복 코드의 메소드 추출 커넥션을 가져오는 중복된 코드를 분리한다. 중복된 DB 연결 코드를 getConnection() 이라는 독립적인 메소드로 만들어둔다. 각 DAO 메소드에서는 이렇게 분리한 getConnection() 메소드를 호출해서 DB 커넥션을 가져오게 만든다. 메소드가 많을 때, 이렇게 분리 해놓는다면 수정할때 굉장히 편해진다. 관심의 종류에 따라 코드를 구분해놓았기 때문에 한 가지 관심에 대한 변경이 일어난 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다. 관심이 다른 코드가 있는 메소드에는 영향을 주지도 않을 뿐더러, 관심 내용이 독립적으로 존재하므로 수정도 간단해졌다.

/ 변경사항에 대한 검증: 리팩토링과 테스트 앞에서의 메소드를 분리한 방법은 기능에 영향을 주지 않으면서 코드의 구조만 변경한다. 기능 추가가 되거나 바뀐 것은 없지만 UserDao는 훨씬 깔끔해졌고 미래의 변화에 좀 더 손쉽게 대응할 수 있는 코드가 됐다. 이러한 작업을 ’리팩토링’ 이라고 한다. 또한 위에서 사용한 getconnction()이라고 하는 중복된 코드를 뽑아내는 것을 리팩토링에서는 ’메소드 추출 기법’이라고 부른다.

- DB 커넥션 만들기의 독립 문제상황 : UserDao 가 발전하여 UserDao를 구매하겠다는 주문이 들어온 경우, 납품과정에서 문제가 발생했다. N 사과 D사가 각기 다른종류의 DB를 사용하고자 하고, DB 커넥션을 가져오는데 있어 독자적으로 만든 방법을 적용하고 싶어한다 해결 : UserDao 소스코드를 N사와 D사에 제공해주지 않고도 고객 스스로 원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 해야 한다.

/ 상속을 통한 확장 기존 UserDao 코드를 한단계 더 분리한다. UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상메소드로 만든다. 이 추상 클래스를 N사와 D사에게 판매한다. UserDao를 구입한 포탈사들은 UserDao를 상속해서 각각의 서브클래스를 만든다. 서브클래서에서 추상메소드로 선언했던 getConnection() 메소드를 원하는 방식대로 구현할 수 있다. 이렇게 하면 추상메소드를 원하는 방식으로 확장한 수 UserDao의 기능과 함께 사용가능하다. 하지만 상속은, 자바가 클래스의 다중 상속을 허용하지 않고, 상하위 클래스의 관계가 생각보다 밀접하여 발생하는 단점이 있다.

1. DAO의 확장
- 클래스의 분리 상속관계가 아닌 완전히 독립적인 클래스를 만든다. 방법 : DB커넥션과 관련된 부분을 서브클래스가 아니라 아예 별도의 클래스에 담는다 그리고 이렇게 만든 클래스를 UserDao가 이용하게 한다. 이 경우 상속을 이용했을 때와 마찬가지로 자유로운 확장이 가능하게 하려면 두 가지 문제를 해결해야 한다. 첫 번째는 메소드가 많아질 때 작업의 양이 너무 커진다는 문제이고, 두번쨰는 DB커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고있어야 한다는 점이다.
- 인터페이스의 도입 가장 좋은 해결책은 두개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것이다. 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업이며, 자바가 추상화를 위해 제공하는 가장 유용한 도구가 인터페이스다. 인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이다. 따라서 구현방법은 나타나 있지 않으며, 인터페이스를 구현한 클래스들이 알아서 결정한다. 그러나 이 경우에도 여전히 UserDao 소스코드를 함께 제공하기 때문에, 고객에게 자유로운 DB 커넥션 확장 기능을 가진 UserDao를 제공할 수가 없다.
- 관계설정 책임의 분리 사용되는 오브젝트를 서비스(UserDao), 사용하는쪽을 클라이언트(main) 이라고 부른다. UserDao의 모든 코드는 ConnectionMaker 인터페이스 외에는 어떤 클래스와도 관계를 가져서는 안 되게 해야 한다. 클래스 사이에 관계가 만들어진 것이 아니라 단지 오브젝트 사이에 나이내믹한 관계가 만들어지는 것이다. 하지만 오브젝트 사이의 관계는 그렇지 않다. 코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다. 다형성이라는 특징 때문이다. 오브젝트 사이에 런타임 사용관계 또는 링크, 또는 의존관계라고 불리는 관계를 맺어주면 된다. 런타임 오브젝트 관계를 갖는 구조로 만들어주는 게 바로 클라이언트의 책임이다. 이 경우 DB 커넥션을 가져오는 방법을 어떻게 변경하든 UserDao 코드는 아무런 영향을 받지 않는다.
- 원칙과 패턴 /개방 폐쇄 원칙 깔끔한 설계를 위해 적용 가능한 객체 지향 설계 원칙 중의 하나다. 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 바로 이 개방 폐쇄원칙을 따른다
    
    /높은 응집도와 낮은 결합도 개방 폐쇄 원칙은 ‘높은 응집도와 낮은 결합도’라는 소프트웨어 개발의 고전원리로도 설명가능 높은 응집도 : 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것이다. 즉 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다. 낮은 결함도 : 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다. 느슨한 연결은 관계를 유지하는데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고 나머지는 서로 독립적이고 알 필요도 없게 만들어 주는 것이다.
    
    /전략 패턴 전략패턴은 자신의 기능맥락(Context, UserDao)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.
    
1. 제어의 역전
- 오브젝트 팩토리 UserDaoTest 를 분리해서 UserDao와 ConnectionMaker 구현 클래스의 오브젝트를 만드는 것과, 그렇게 만들어진 두 개의 오브젝트가 연결돼서 사용될 수 있도록 관계를 맺어주는 작업을 해야 한다.

/팩토리 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 오브젝트를 ‘팩토리**’**라고 한다. 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용하는 것이다. 팩토리 역할을 맡을 클래스를 DaoFactory 라고 하고, UserDao, ConnectionMaker 작업을 여기로 옮긴다.

/설계도로서의 팩토리 UserDao와 ConnectionMake가 실질적인 로직을 담당하는 컴포넌트라면, DaoFactory는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할을 한다. 설계도란, 어떤 오브젝트가 어떤 오브젝트를 사용하는지를 정의해놓은 코드이다, DaoFactory를 분리하면, 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있다.

- 오브젝트 팩토리의 활용 userDao() 메소드를 복사해서 다른 DAO를 만든다면 , 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 기능이 중복되어버린다. 중복을 해결하려면 이를 분리해내야 한다. ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 코드를 별도의 메소드로 뽑아내자. 그리고 다른 DAO 를 생성하는 각 메소드에서는 새로만든 ConnectionMaker 생성용 메소드를 이용한다. 이 경우 DAO 팩토리 메소드가 많아져도 문제없고, 수정을 하게되더라도 ConnectionMaker 생성용 메소드만 수정하면 모든 DAO 팩토리 메소드에 적용된다.
- 제어권의 이전을 통한 제어관계 역전 일반적으로 프로그램의 흐름은 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조다. 제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다**.** 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다. IoC를 적용하면 설계가 깔끔해지고 유연성이 증가하며 확장성이 좋아진다. 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리등을 관장하는 존재가 필요하다. 스프링은 IoC를 모든 기능의 기초가 되는 기반기술로 삼고 있으며, IoC를 극한까지 적용하고 있는 프레임워크다.
1. 스프링의 loC
- 오브젝트 팩토리를 이용한 스프링 IoC /애플리케이션 컨텍스트와 설정정보 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(bean)이라고 부른다. 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리킨다. 또한 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리 라고 부른다. 보통 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트를 주로 사용한다. 애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈(오브젝트)의 생성, 관계설정 등의 제어 작업을 총괄한다. 애플리케이션은 애플리케이션 컨텍스트와 그 설정정보를 따라서 만들어지고 구성된다.
    
    / DaoFactory를 사용하는 애플리케이션 컨텍스트 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할수 있도록 @Configuration 어노테이션, 오브젝트를 만들어 주는 메소드에는 @Bean 어노테이션을 붙인다. @Configuration이 붙은 자바 코드를 설정정보로 사용하려면 AnnotationConfigApplicationContext를 이용한다. getBean() 메소드는 ApplicationContext가 관리하는 오브젝트를 요청하는 메소드다.
    
- 애플리케이션 컨텍스트의 동작방식 어플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점은 다음과 같다.

/클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다 클라이언트가 오브젝트를 가져오려면 필요할 때마다 팩토리 오브젝을 생성해야 하는 번거로움이 있다. 어플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 많아져도 직접 사용할 필요가 없다. 또 자바코드를 작성하는대신 XML 처럼 단순한 방법을 사용해 어플리케이션 컨텍스트가 사용할 IoC설정정보를 만들 수 있다.

/어플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다 어플리케이션 컨텍스트는 오브젝트가 만들어지는 방식, 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정방식의 다변화, 인터셉팅 등 다양한 기능을 제공한다.

/어플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다 getBean() 메소드는 빈의 이름을 이용해 빈을 찾아준다. 타입만으로 빈을 검색하거나 특별한 어노테이션 설정이 되어있는 빈을 찾을 수도 있다.

- 스프링 IoC의 용어 정리

빈 : 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻. 빈 팩토리 : 스프링의 IoC를 담당하는 핵심 컨테이너. 빈을 등록,생성,조회 등 부가적인 빈을 관리하는 기능을 담당. 보통은 빈 팩토리를 바로 사용하지않고 이를 확장한 어플리케이션 컨텍스트를 이용한다. 애플리케이션 컨텍스트 : 빈 팩토리를 확장한 IoC 컨테이너. 스프링이 제공하는 어플리케이션 지원 기능을 모두 포함해서 이야기하는 것. 설정정보/설정 메타정보 : 스프링의 설정정보란 어플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다. 영어로는 configuration 컨테이너 또는 IoC 컨테이너 : IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다. 스프링 프레임워크 : IoC 컨테이너, 어플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용한다.

1. 싱글톤 레지스트리와 오브젝트 스코프
- 싱글톤레지스트리로서의 애플리케이션 컨텍스트
    
    /서버 애플리케이션과 싱글톤 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다. 서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트이다. 서블릿 클래스당 하나의 오브젝트만 만들어주고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다. 이렇게 어플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리다.
    
    /싱글톤 패턴의 한계 private 생성자를 갖고 있기 때문에 상속할 수 없다 싱글톤은 테스트하기가 힘들다 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다
    
    /싱글톤 레지스트리 자바의 기본적인 싱글톤 패턴의 구현방식은 여러가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하며, 이것이 싱글톤 레지스트리다. 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인패턴(싱글톤패턴은 제외) 등을 적용하는데 아무런 제약이 없다
    
- 싱글톤과 오브젝트의 상태 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리에 주의를 기울여야 한다. 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다, 상태가 없는 방식으로 클래스를 만드는 경우에는, 파라미터와 로컬변수, 리턴 값 등을 이용해서 만든다.
- 스프링 빈의 스코프 스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위를 빈의 스코프라고 한다. 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 외의 대표적인 스코프는 프로토타입이며 이는 싱글톤과 달리 컨테이너에 빈을 요청할 때 마다 매번 새로운 오브젝트를 만든다. 그 외에 요청 스코프, 세션 스코프 등이 있다.
1. 의존관계 주입
- 제어의 역전(IoC)과 의존관계 주입 IoC는 매우 느슨하게 정의돼서 폭넓게 사용되는 용어이기 때문에, 의존관계 주입(DI)라는 좀 더 의도가 명확히 드러나는 이름을 사용한다. 스프링 IoC기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다.
- 런타임 의존관계 설정 의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업을 말한다.

/인터페이스에만 의존하고 있어야 한다. /런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다. /의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

- 의존관계 검색과 주입 스프링이 제공하는 IoC방법에는 의존관계 주입 외에도, 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 ‘의존관계 검색’이 있다. 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.
- 메소드를 이용한 의존관계 주입 의존관계 주입 시 반드시 생성자를 사용해야 하는 것은 아니다. 일반 메소드를 이용해 DI 하는데는 크게 두 가지 방법이 있다.

/ 수정자 메소드를 이용한 주입 수정자 메소드는 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도로 주로 사용된다.

/ 일반 메소드를 이용한 주입 수정자처럼 파라미터를 하나만 가지는게 싫다면 일반 메소드를 DI용으로 사용할 수도 있다. 생성자가 수정자 메소드보다 나은 점은 한 번에 여러 개의 파라미터를 받을 수 있다는 점이다.